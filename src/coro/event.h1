#pragma once
#include "async_task.h"
#include <assert.h>

struct Event {
    struct Awaitable {
        coroutine_handle<> handle = nullptr;

        bool await_ready() const noexcept { return false; }
        void await_resume() const noexcept {}
        void await_suspend(coroutine_handle<> h) noexcept { handle = h; }

        void resume() { handle.resume(); }

        bool IsWaiting() { return (bool)handle; }
    };

    Awaitable mAwaitable = {};
    bool mWait = true;
    std::exception_ptr mException = nullptr;

    AsyncTask<void> wait() {
        if (mWait) {

            struct A {
                Awaitable &mAwaitable;
                ~A() { mAwaitable = {}; }
            } a{mAwaitable};
            (void)a;

            co_await mAwaitable;
            if (mException) {
                auto exception = mException;
                mException = nullptr;
                std::rethrow_exception(exception);
            }
        } else {
            mWait = true;
            co_return;
        }
    }

    bool fire() {
        if (mAwaitable.IsWaiting()) {
            auto awaitable = mAwaitable;
            mAwaitable = {};
            awaitable.resume();
            return true;
        } else {
            mWait = false;
        }
        return false;
    }

    bool fireException(std::exception &exception) {
        try {
            throw exception;
        } catch (...) {
            mException = std::current_exception();
        }

        if (mAwaitable.IsWaiting()) {
            mAwaitable.resume();
            return true;
        }
        return false;
    }

    ~Event() {
        std::runtime_error error("destruct");
        fireException(error);
    }
};
